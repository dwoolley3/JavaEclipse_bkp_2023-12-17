//import java.util.*;
//import java.util.regex.*;
//import java.text.*;
//import java.math.*;


public class factors_powers_SRM628_Div1_L1_DivisorsPower
{
	public long findArgument(long n)
	{
		double eps = 1e-7;  //values 1e-1 thru 1e-9 work, but 1e-7 is best
		for (int p = 62; p > 1; p--)
		{
			double num = Math.pow(n,  1.0/p); 
			long numL = (long)(num + eps);  //123456789.123456, precise to 15-17 dig
			numL = Math.round(num);         //Math.round takes a double, returns a long

//			boolean ok = true;
//			double powD = 1;
//			for (int i = 0; i < p && ok; i++)
//			{
//				powD *= numL;   //powD as double loses precision needed for a long
//				if (powD > n+1) 
//					ok = false;
//			}
//			if (!ok) continue;
//			if (Math.pow(numL, p) > n + 1) 
//				continue;
				
			//This also can work since it will not overflow
			//long pow = 1;
			//for (int i = 0; i < p; i++) 
			//	pow *= numL;
				
			//Alternative way that does not need to check for overflow
			//long n2 = n;
			//ok = true;
			//for (int i = 0; i < p && ok; i++)
			//	if (n2 % numL == 0)
			//		n2 /= numL;
			//	else
			//		ok = false;
			//if (ok && n2 == 1)
			
			long pow = power(numL, p);
			if (pow == n)
				if (countFactors(numL) == p)
					return numL;		
		}
		return -1;
	}
	
	long power(long a, int p)
	{		
		long pow = 1, INF = Long.MAX_VALUE;
		for (int i = 0; i < p; i++)
			if (pow > INF / a)
				pow = INF;
			else
				pow *= a;
		return pow;
	}
	
    @SuppressWarnings("unused")
	private int cntFactors(long n)
    {
        int facts = 0, i;
        for (i = 1; i * i < n; i++)
            if (n % i == 0) facts += 2;
        if (i * i == n) facts++;
        return facts;
    }
    
    private int countFactors(long n)
    {
        int facts = 1;
        for (int i = 2; i * i <= n; i++)
        {
            if (n % i == 0) 
            {
            	int cnt = 1;
            	while (n % i == 0)
            	{
            		n /= i;
            		cnt++;
            	}            
            	facts *= cnt;
            }
        }
        if (n > 1) facts *= 2;
        return facts;
    }

	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
	private static boolean KawigiEdit_RunTest(int testNum, long p0, boolean hasAnswer, long p1) {
		System.out.print("Test " + testNum + ": [" + p0);
		System.out.println("]");
		factors_powers_SRM628_Div1_L1_DivisorsPower obj;
		long answer;
		obj = new factors_powers_SRM628_Div1_L1_DivisorsPower();
		long startTime = System.currentTimeMillis();
		answer = obj.findArgument(p0);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + p1);
		}
		System.out.println("Your answer:");
		System.out.println("\t" + answer);
		if (hasAnswer) {
			res = answer == p1;
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		all_right = true;
		
		long p0;
		long p1;
		
		// ----- test 2 -----
		p0 = 9109555799784049L;  //pow2 as double loses precision for long! 
		p1 = 208849L;
		all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
		// ------------------
		// ----- test 2 -----
		p0 = 1000000000000000000L;
		p1 = 100L;
		all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 0 -----
		p0 = 576460752303423488L;
		p1 = -1L;
		all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 0 -----
		p0 = 4L;
		p1 = 2L;
		all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 1 -----
		p0 = 10L;
		p1 = -1L;
		all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 2 -----
		p0 = 64L;
		p1 = 4L;
		all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 3 -----
		p0 = 10000L;
		p1 = 10L;
		all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 4 -----
		p0 = 2498388559757689L;
		p1 = 49983883L;
		all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
		// ------------------
		
		if (all_right) {
			System.out.println("You're a stud (at least on the example cases)!");
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
